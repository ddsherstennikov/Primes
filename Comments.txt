Комментарии для NivalApp, Денис Шерстенников
Написание, тестирование, проектирование, отладка, поиск алгоритмов, создание
инфраструктуры для предрассчитанных простых чисел — всё вместе заняло около
60 рабочих часов.
План:
0) Нашёл оптимальный по критерию время/детерминированность алгоритм - BSPW
1) Сделал синхронный ввод вывод 6-байтовых чисел
2) Реализовал алгоритм BPSW
3) Сделал аггрегацию работы алгоритма на входном файле
4) Сделал решето Эратосфена для отладки и прогнал тесты
5) Сделал инфраструктуру батников, флагов, эталонов времени, результатов и списков
простых чисел, прогнать тесты на файлах 1КБ-2ГБ (15 файлов)
6) Сделал простую реализацию асинхронности для BSPW ( для начала была совсем
дурацкая — раздавала на четыре потока по числу и ждала всех, потом снова ); сначала
имплементировал обычные CLR Threads, потом пробовал ThreadingPool и Tasks.
Остановился на ThreadingPool, так как ожидал, что понадобится recycling потоков.
7) Снова тестирование и отладка, оказалось что конечно такая асинхронность тормознее
синхронной версии
8) Оптимизировал BSPW, встроив таблицу простых чисел в пределах 0..1000 (до этого
прерасчитывалась)
9) Рассчитал сколько предрассчитанных простых чисел могу хранить в оперативке (исходя
из 1ГБ), сконвертировал таблицы простых чисел, научился считывать их, оптимально
хранить (шарповая и даже плюсовая хештаблицы очень много ели засчёт объектности,
поэтому стал хранить в плоском отсортированном массиве и юзать на нём
std::binary_search)
10) Протянул обращение к хештаблице из C++/CLI в C#, протестировал, убрал оверхеды
по памяти/времени, какие нашёл
11) Протестировал время — со старой ужасной асинхронностью и хештаблицей
программа оказалась быстрее синхронной версии без хештаблицы
12) Оптимизировал параллелизм. Была идея давать каждому потоку числа с каким-то
одним остатком от деления на число потоков (если их два, то первому-чётные, второму —
нечётные). Понял, что вряд ли справлюсь с оверхедом по слиянию результатов в разумные
сроки, плюс само слияние может занять больше времени чем обработка чисел на
простоту, а если ещё и его распараллелить, то всё совсем сложно.
Пришёл к мысли для маленьких файлов ( <= 4КБ ) совсем не юзать многопоточность, т. к.
они обрабатываются в пределах 100ms на одном потоке. Большие файлы решил нарезать
на равные (за исключением последнего) куски и один раз раздавать потокам, потом всех
ждать. Чисто статистически, потоки должны заканчивать работу примерно одновременно,
т. к. распределение простых чисел случайно и большой размер куска компенсируют
любую неоднородность.
Единственный минус — результаты пришлось «сшивать», но тут проблема была больше в
грамотной организации отладки.
Потестил на оптимальное число потоков, оказалось действительно равным числу
логических процессоров (у меня 1 проц с 4 ядрами без HyperThreading => в 4 потока для
моей машины оптимально, увеличение числа потоков не дало видимого прироста
производительности)
13) После многих тестов все найденные на тестовых 15 файлах баги были устранены (по
сравнению с результатами решета Эратосфена на них же), перформанс улучшился
примерно в 10 раз по сравнению с синхронной версией без хештаблицы
14) Сделал UI с прогресс барами для загрузки хештаблиц и обработки файла.
15) Провёл финальный тест с решетом, всё ок
16) удалил дебажный крэп
Не сделал:
1) Остался небольшой лаг при инициализации потоков, поэтому прогрессБар в самом
начале на маленькой файле может резко подскочить процентов до 60.
2) Не стал пробовать юзать чистый алгоритм Миллера-Рабина, решил, что BSPW,
включающий его достаточно оптимален. Время могло бы улучшиться в 1,5-3 раза.
3) Убрал половину дебажного функционала, т. к. он уже не был нужен, а поддерживать
былто времязатратно.
4) Не стал возвращаться от ThreadPool к Threads. Т.к. Recycling потоков оказался не нужен,
можно было бы избежать небольшого оверхеда, связанного с пулом потоков.
5) Не стал реализовывать побитовые признаки деления (кроме как для 2).
6) Не стал делать x64 версию с возможностью варьировать размер предрассчитанной
таблицы (сейчас 250 миллионов простых занимают 1.2ГБ, на 4х Гигах можно было бы
хранить около миллиарда отсортированных первых простых чисел, что ускорило бы прогу)
7) Не стал углубляться в исследования алгоритмов распознавание простых чисел, не стал
изучать как их распределяют по разным видам.
8) Экспериментируя с числом потоков, я наткнулся на странные вылеты при создании
больше 45 на ThreadPool. Причём, насколько я помню, только в debug-версии, в Release
вроде как всё ок было. Не стал расследовать.
Значимые решения:
1) Я использовал C++/CLI для BSPW и хештаблицы; может, это читерство, но писать эти
фрагменты на чистом C# я не вижу смысла. Хештаблица на C# занимала больше 4ГБ, в
плоском массиве (разделённом на 32 битные и 64 битные числа) – ровно 1.2ГБ RAM.
2) Алгоритм BSPW сам писать не стал, взял готовую плюсовую реализацию со знакомого
сайта, которым пользовался при подготовке к ШАД: http://e-maxx.ru/algo/bpsw. Попутно
нашёл у автора ошибку, которая выявилась только на параллельной версии. Переписывать
не хотелось и стало бы менее оптимально, это было ещё одним фактором в пользу C+
+/CLI.
3) Пробовал перевести всё на x64, когда C# съел все 2ГБ памяти хештаблицей. Начались
проблемы с конфигурациями проектов, так как раньше никогда под x64 не писал.
Вообщем, мои 4ГБ C# тоже съел, поэтому сначала стал использовать C++ hash_set, а когда
и он исчерпал оперативку (правда всего 2ГБ, на 4х не пробовал), то решил использовать
binary_search на плоском массиве, благо он был уже упорядоченный. Об этом я выше уже
писал.
4) Экспериментируя с числом потоков, я наткнулся на странные вылеты при создании
больше 45 на ThreadPool. Причём, насколько я помню, только в debug-версии, в Release
вроде как всё ок было. Не стал расследовать.
5) Т.к. с асинхронностью мало работал раньше, заюзал простейшие захваты на
пользовательском уровне оператором lock.
6) По этой же причине, не стал копаться в ThreadLocalStorage и ExecutionContext, а просто
создал классы-обёртки для ThreadProc, хранившие все данные в полях экземпляра.
7) Простые числа скачивал отсюда — http://www.primos.mat.br/indexen.html, прищшёл по
ссылке с англоязычной википедии.
Строка запуска:
NivalApp.exe in_test [silent] [nohashtable], где
in_test – файл входных данных относительно директории с .exe-файлом
[silent] – необязательный флаг, при выставлении которого программа выводит только
результат, без отображения прогресса по обработке и загрузке предрасчитанных чисел,
времени, числа потоков
[nohashtable] - необязательный флаг, при выставлении которого программа использует
только BSPW, без обращений к хранимым числам. При этом 1+ ГБ таблица чисел в память
не загружается. Для маленьких файлов улучшает перформанс, для больших снижает. При
размере от 1МБ точно заметно снижение, при размере меньше 10КБ лучше без
предрассчитанных.
